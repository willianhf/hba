type ApplicationError implements BaseError {
  code: String!
  message: String!
  name: String!
}

enum ApprovalStatus {
  ACCEPTED
  DENIED
  IDLE
}

type AuthenticationError implements BaseError {
  code: String!
  message: String!
  name: String!
}

interface BaseError {
  code: String!
  message: String!
  name: String!
}

input ConfirmUserVerificationInput {
  clientMutationId: ID
}

type ConfirmUserVerificationPayload {
  clientMutationId: ID
  itWorked: Boolean!
  user: User!
}

input CreatePlayerInput {
  clientMutationId: ID
  iconsIds: [String!]!
  nbaPlayerId: String!
  positionId: String!
}

type CreatePlayerPayload {
  clientMutationId: ID
  player: Player!
}

input CreateSeasonInput {
  clientMutationId: ID
  isCurrent: Boolean!
  name: String!
}

type CreateSeasonPayload {
  clientMutationId: ID
  season: Season!
}

input CreateUserInput {
  clientMutationId: ID
  password: String!
  username: String!
}

type CreateUserPayload {
  clientMutationId: ID
  jwtToken: String!
  sessionId: String!
  user: User!
  verificationCode: String!
}

input CreateUserVerificationInput {
  clientMutationId: ID
}

type CreateUserVerificationPayload {
  clientMutationId: ID
  verificationCode: String!
}

scalar Date

type ErrorField {
  field: String
  message: String!
}

type ForbiddenError implements BaseError {
  code: String!
  message: String!
  name: String!
}

type Icon implements Node {
  id: ID!
  name: String!
}

enum ImageSize {
  Large
  Small
}

input LoginInput {
  clientMutationId: ID
  password: String!
  username: String!
}

type LoginPayload {
  clientMutationId: ID
  sessionId: String!
  token: String!
  user: User!
  verificationCode: String
}

input LogoutInput {
  clientMutationId: ID
  sessionId: String!
}

type LogoutPayload {
  clientMutationId: ID
  itWorked: Boolean!
}

input MakeSeasonCurrentInput {
  clientMutationId: ID
  seasonId: ID!
}

type MakeSeasonCurrentPayload {
  clientMutationId: ID
  itWorked: Boolean!
}

type Mutation {
  confirmUserVerification(input: ConfirmUserVerificationInput!): MutationConfirmUserVerificationResult!
  createPlayer(input: CreatePlayerInput!): MutationCreatePlayerResult!
  createSeason(input: CreateSeasonInput!): CreateSeasonPayload!
  createUser(input: CreateUserInput!): MutationCreateUserResult!
  createUserVerification(input: CreateUserVerificationInput!): CreateUserVerificationPayload!
  login(input: LoginInput!): MutationLoginResult!
  logout(input: LogoutInput!): MutationLogoutResult!
  makeSeasonCurrent(input: MakeSeasonCurrentInput!): MakeSeasonCurrentPayload!
}

union MutationConfirmUserVerificationResult = ApplicationError | AuthenticationError | ConfirmUserVerificationPayload

union MutationCreatePlayerResult = ApplicationError | AuthenticationError | CreatePlayerPayload | ValidationInputError

union MutationCreateUserResult = CreateUserPayload | ValidationInputError

union MutationLoginResult = ApplicationError | LoginPayload

union MutationLogoutResult = ApplicationError | AuthenticationError | LogoutPayload

type NBAPlayer implements Node {
  firstName: String!
  id: ID!
  imageUrl(size: ImageSize = Large): String!
  lastName: String!
}

interface Node {
  id: ID!
}

type PageInfo {
  endCursor: String
  hasNextPage: Boolean!
  hasPreviousPage: Boolean!
  startCursor: String
}

type Player implements Node {
  icons: [Icon!]!
  id: ID!
  nbaPlayer: NBAPlayer
  position: Position
  season: Season
  status: ApprovalStatus!
  user: User
}

type Position implements Node {
  id: ID!
  name: String!
}

type Query {
  currentSeason: Season!
  findPlayers(seasonId: String!): [Player!]!
  findUserPlayersBySeason(after: String, before: String, first: Int, last: Int): QueryFindUserPlayersBySeasonConnection!
  habboProfileExists(username: String!): Boolean!
  icons: [Icon!]!
  nbaPlayers(search: String!): [NBAPlayer!]!
  node(id: ID!): Node
  nodes(ids: [ID!]!): [Node]!
  positions: [Position!]!
  seasons(after: String, before: String, first: Int, last: Int): QuerySeasonsConnection!
  user: User!
}

type QueryFindUserPlayersBySeasonConnection {
  edges: [QueryFindUserPlayersBySeasonConnectionEdge!]!
  pageInfo: PageInfo!
}

type QueryFindUserPlayersBySeasonConnectionEdge {
  cursor: String!
  node: Player!
}

type QuerySeasonsConnection {
  edges: [QuerySeasonsConnectionEdge!]!
  pageInfo: PageInfo!
}

type QuerySeasonsConnectionEdge {
  cursor: String!
  node: Season!
}

type Season implements Node {
  id: ID!
  name: String!
}

type User implements Node {
  canRequestPlayer: Boolean!
  createdAt: Date
  id: ID!
  isAdmin: Boolean!
  isVerified: Boolean!
  password: String!
  players(after: String, before: String, first: Int, last: Int): UserPlayersConnection!
  username: String!
}

type UserPlayersConnection {
  edges: [UserPlayersConnectionEdge!]!
  pageInfo: PageInfo!
}

type UserPlayersConnectionEdge {
  cursor: String!
  node: Player!
}

type ValidationInputError implements BaseError {
  code: String!
  fields: [ErrorField!]!
  message: String!
  name: String!
}
